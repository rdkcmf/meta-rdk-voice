Material from avs-device-sdk and alexa-smart-screen-sdk is Copyright Amazon.com, Inc. or its affiliates, 
and licensed under the Apache License, Version 2.0


From 603e8fa0290d2d9dd16bb8e861699daa424a56be Mon Sep 17 00:00:00 2001
From: sudharsan ramakrishnan <sudharsan_ramakrishnan@comcast.com>
Date: Sun, 18 Jul 2021 05:47:49 +0000
Subject: [PATCH] smartscreen upgrade and crash fix-2.6

---
 WPEPluginAVS/Impl/SmartScreen/SmartScreen.cpp | 962 ++++++++++++++++++-------------
 WPEPluginAVS/Impl/SmartScreen/SmartScreen.h   |   7 +-
 2 files changed, 578 insertions(+), 391 deletions(-)

diff --git a/WPEPluginAVS/Impl/SmartScreen/SmartScreen.cpp b/WPEPluginAVS/Impl/SmartScreen/SmartScreen.cpp
index cc3d58a..6626eaa 100644
--- a/WPEPluginAVS/Impl/SmartScreen/SmartScreen.cpp
+++ b/WPEPluginAVS/Impl/SmartScreen/SmartScreen.cpp
@@ -33,19 +33,25 @@
 #include <AVSCommon/Utils/LibcurlUtils/LibcurlHTTP2ConnectionFactory.h>
 #include <AVSCommon/Utils/Logger/LoggerSinkManager.h>
 #include <AVSCommon/Utils/Network/InternetConnectionMonitor.h>
-#include <Alerts/Storage/SQLiteAlertStorage.h>
+//#include <Alerts/Storage/SQLiteAlertStorage.h>
 #include <Audio/AudioFactory.h>
 #include <CBLAuthDelegate/CBLAuthDelegate.h>
 #include <CBLAuthDelegate/SQLiteCBLAuthDelegateStorage.h>
 #include <ContextManager/ContextManager.h>
-#include <Notifications/SQLiteNotificationsStorage.h>
+//#include <Notifications/SQLiteNotificationsStorage.h>
 #include <SQLiteStorage/SQLiteMiscStorage.h>
 #include <Settings/Storage/SQLiteDeviceSettingStorage.h>
 
 #include <SmartScreen/Communication/WebSocketServer.h>
 
-#include <SmartScreen/SampleApp/AplCoreEngineSDKLogBridge.h>
-#include <SmartScreen/SampleApp/AplCoreGuiRenderer.h>
+
+
+#include <acsdkAlerts/Storage/SQLiteAlertStorage.h>
+#include <AVS/acsdkNotifications/SQLiteNotificationsStorage.h>
+#include <APLClient/AplCoreGuiRenderer.h>
+
+//#include <SmartScreen/SampleApp/AplCoreEngineSDKLogBridge.h>
+//#include <SmartScreen/SampleApp/AplCoreGuiRenderer.h>
 #include <SmartScreen/SampleApp/JsonUIManager.h>
 #include <SmartScreen/SampleApp/KeywordObserver.h>
 #include <SmartScreen/SampleApp/LocaleAssetsManager.h>
@@ -54,6 +60,53 @@
 #include <cctype>
 #include <fstream>
 
+#include <AVSCommon/AVS/Initialization/InitializationParametersBuilder.h>
+
+#include <acsdkManufactory/Manufactory.h>
+#include <ACL/Transport/HTTP2TransportFactory.h>
+#include <ACL/Transport/PostConnectSequencerFactory.h>
+#include <AVS/AVSCommon/AVS/CapabilitySemantics/CapabilitySemantics.h>
+#include <AVS/AVSCommon/AVS/Initialization/InitializationParametersBuilder.h>
+#include <AVS/AVSCommon/SDKInterfaces/PowerResourceManagerInterface.h>
+#include <AVS/AVSCommon/Utils/LibcurlUtils/LibcurlHTTP2ConnectionFactory.h>
+#include <AVS/AVSCommon/Utils/UUIDGeneration/UUIDGeneration.h>
+#include <AVSGatewayManager/AVSGatewayManager.h>
+#include <AVSGatewayManager/Storage/AVSGatewayManagerStorage.h>
+#include <SynchronizeStateSender/SynchronizeStateSenderFactory.h>
+
+#include "SmartScreen/SampleApp/ExternalCapabilitiesBuilder.h"
+#include "SmartScreen/SampleApp/KeywordObserver.h"
+#include "SmartScreen/SampleApp/LocaleAssetsManager.h"
+#include "SmartScreen/SampleApp/SampleApplication.h"
+#include "SmartScreen/SampleApp/SampleApplicationComponent.h"
+#include "SmartScreen/SampleApp/SmartScreenCaptionPresenter.h"
+
+
+#include <AVS/AVSCommon/AVS/Initialization/AlexaClientSDKInit.h>
+#include <AVS/AVSCommon/SDKInterfaces/Bluetooth/BluetoothDeviceConnectionRuleInterface.h>
+#include <AVS/AVSCommon/SDKInterfaces/Bluetooth/BluetoothDeviceManagerInterface.h>
+#include <AVS/AVSCommon/SDKInterfaces/Diagnostics/ProtocolTracerInterface.h>
+#include <AVS/AVSCommon/SDKInterfaces/Endpoints/EndpointBuilderInterface.h>
+#include <AVS/AVSCommon/Utils/Configuration/ConfigurationNode.h>
+#include <AVS/AVSCommon/Utils/DeviceInfo.h>
+#include <AVS/AVSCommon/Utils/LibcurlUtils/HTTPContentFetcherFactory.h>
+#include <AVS/AVSCommon/Utils/Logger/Logger.h>
+#include <AVS/AVSCommon/Utils/Logger/LoggerSinkManager.h>
+#include <AVS/AVSCommon/Utils/Network/InternetConnectionMonitor.h>
+#include <acsdkAlerts/Storage/SQLiteAlertStorage.h>
+#include <Audio/AudioFactory.h>
+#include <Audio/MicrophoneInterface.h>
+#include <acsdkBluetooth/BasicDeviceConnectionRule.h>
+#include <acsdkBluetooth/SQLiteBluetoothStorage.h>
+#include <acsdkNotifications/SQLiteNotificationsStorage.h>
+#include <CBLAuthDelegate/CBLAuthDelegate.h>
+#include <CBLAuthDelegate/SQLiteCBLAuthDelegateStorage.h>
+#include <CapabilitiesDelegate/CapabilitiesDelegate.h>
+#include <CapabilitiesDelegate/Storage/SQLiteCapabilitiesDelegateStorage.h>
+#include <SQLiteStorage/SQLiteMiscStorage.h>
+#include <SmartScreen/SampleApp/SampleEqualizerModeController.h>
+#include <Settings/Storage/SQLiteDeviceSettingStorage.h>
+#include <SmartScreen/Communication/WebSocketServer.h>
 namespace WPEFramework {
 namespace Plugin {
 
@@ -66,6 +119,24 @@ namespace Plugin {
     static const std::string FIRMWARE_VERSION_KEY("firmwareVersion");
     static const std::string ENDPOINT_KEY("endpoint");
 
+    static const std::string AUDIO_MEDIAPLAYER_POOL_SIZE_KEY("audioMediaPlayerPoolSize");
+    static const unsigned int AUDIO_MEDIAPLAYER_POOL_SIZE_DEFAULT = 2; 
+
+   
+   // static const std::string WEBSOCKET_INTERFACE_KEY("websocketInterface");
+   // static const std::string WEBSOCKET_PORT_KEY("websocketPort");
+    static const std::string WEBSOCKET_CERTIFICATE("websocketCertificate");
+    static const std::string WEBSOCKET_PRIVATE_KEY("websocketPrivateKey");
+    static const std::string WEBSOCKET_CERTIFICATE_AUTHORITY("websocketCertificateAuthority");
+//    static const std::string AUDIO_MEDIAPLAYER_POOL_SIZE_KEY("audioMediaPlayerPoolSize");
+    static const std::string CONTENT_CACHE_REUSE_PERIOD_IN_SECONDS_KEY("contentCacheReusePeriodInSeconds");
+    static const std::string DEFAULT_CONTENT_CACHE_REUSE_PERIOD_IN_SECONDS("600");
+    static const std::string CONTENT_CACHE_MAX_SIZE_KEY("contentCacheMaxSize");
+    static const std::string DEFAULT_CONTENT_CACHE_MAX_SIZE("50");
+    static const std::string MAX_NUMBER_OF_CONCURRENT_DOWNLOAD_CONFIGURATION_KEY = "maxNumberOfConcurrentDownloads";
+    static const int DEFAULT_MAX_NUMBER_OF_CONCURRENT_DOWNLOAD = 5;
+     
+    
     // Share Data stream Configuraiton
     static const size_t MAX_READERS = 10;
     static const size_t WORD_SIZE = 2;
@@ -83,9 +154,11 @@ namespace Plugin {
     static const std::string DEFAULT_WEBSOCKET_INTERFACE = "127.0.0.1";
     static const int DEFAULT_WEBSOCKET_PORT = 8933;
 
+    
     bool SmartScreen::Initialize(PluginHost::IShell* service, const string& configuration)
     {
-        TRACE_L1("Initializing SmartScreen...");
+        
+    TRACE_L1("Initializing AVSDevice...");
 
         Config config;
         bool status = true;
@@ -108,10 +181,10 @@ namespace Plugin {
             TRACE(AVSClient, (_T("Missing AlexaClient config file")));
             status = false;
         }
-
-        const std::string smartScreenConfig = config.SmartScreenConfig.Value();
-        if ((status == true) && (alexaClientConfig.empty() == true)) {
-            TRACE(AVSClient, (_T("Missing SmartScreenConfig config file")));
+        
+    const std::string smartScreenConfig = config.SmartScreenConfig.Value();
+        if ((status == true) && (smartScreenConfig.empty() == true)) {
+            TRACE(AVSClient, (_T("Missing AlexaClient config file")));
             status = false;
         }
 
@@ -135,362 +208,354 @@ namespace Plugin {
 #endif
         }
 
-        std::vector<std::shared_ptr<std::istream>> configJsonStreams;
-        if ((status == true) && (JsonConfigToStream(configJsonStreams, alexaClientConfig) == false)) {
-            TRACE(AVSClient, (_T("Failed to load alexaClientConfig")));
-            status = false;
+    if (status == true) {
+            status = Init(audiosource, enableKWD, pathToInputFolder, alexaClientConfig, smartScreenConfig);
         }
-        if ((status == true) && (JsonConfigToStream(configJsonStreams, smartScreenConfig) == false)) {
-            TRACE(AVSClient, (_T("Failed to load smartScreenConfig")));
-            status = false;
-        }
-#if defined(KWD_PRYON)
-        if (enableKWD) {
-            if ((status == true) && (JsonConfigToStream(configJsonStreams, pathToInputFolder + "/localeToModels.json") == false)) {
-                TRACE(AVSClient, (_T("Failed to load localeToModels.json")));
-                status = false;
-            }
-        }
-#endif
-        if ((status == true) && (avsCommon::avs::initialization::AlexaClientSDKInit::initialize(configJsonStreams) == false)) {
-            TRACE(AVSClient, (_T("Failed to initialize SDK!")));
-            return false;
-        }
-
-        if (status == true) {
-            status = Init(audiosource, enableKWD, pathToInputFolder);
-        }
-
         return status;
-    }
+}
 
-    bool SmartScreen::Init(const std::string& audiosource, const bool enableKWD, const std::string& pathToInputFolder)
+  bool SmartScreen::Init(const std::string& audiosource, const bool enableKWD, const std::string& pathToInputFolder, const std::string alexaClientConfig, const std::string smartScreenConfig)
     {
-        auto config = avsCommon::utils::configuration::ConfigurationNode::getRoot();
-
-        std::shared_ptr<avsCommon::utils::DeviceInfo> deviceInfo = avsCommon::utils::DeviceInfo::create(config);
-        if (!deviceInfo) {
-            TRACE(AVSClient, (_T("Failed to create deviceInfo")));
-            return false;
-        }
-        int firmwareVersion = static_cast<int>(avsCommon::sdkInterfaces::softwareInfo::INVALID_FIRMWARE_VERSION);
-        config[SAMPLE_APP_CONFIG_KEY].getInt(FIRMWARE_VERSION_KEY, &firmwareVersion, firmwareVersion);
-
-        auto customerDataManager = std::make_shared<registrationManager::CustomerDataManager>();
-        if (!customerDataManager) {
-            TRACE(AVSClient, (_T("Failed to create customerDataManager")));
-            return false;
-        }
-
-        // speakers and media players
-        auto httpContentFetcherFactory = std::make_shared<avsCommon::utils::libcurlUtils::HTTPContentFetcherFactory>();
-
-        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::SpeakerInterface> speakSpeaker;
-        std::tie(m_speakMediaPlayer, speakSpeaker) = createApplicationMediaPlayer(
-            httpContentFetcherFactory,
-            false,
-            avsCommon::sdkInterfaces::SpeakerInterface::Type::AVS_SPEAKER_VOLUME,
-            "SpeakMediaPlayer");
-        if (!m_speakMediaPlayer || !speakSpeaker) {
-            TRACE(AVSClient, (_T("Failed to create SpeakMediaPlayer")));
-            return false;
-        }
-
-        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::SpeakerInterface> audioSpeaker;
-        std::tie(m_audioMediaPlayer, audioSpeaker) = createApplicationMediaPlayer(
-            httpContentFetcherFactory,
-            false,
-            avsCommon::sdkInterfaces::SpeakerInterface::Type::AVS_SPEAKER_VOLUME,
-            "AudioMediaPlayer");
-        if (!m_audioMediaPlayer || !audioSpeaker) {
-            TRACE(AVSClient, (_T("Failed to create AudioMediaPlayer")));
-            return false;
-        }
-
-        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::SpeakerInterface> alertsSpeaker;
-        std::tie(m_alertsMediaPlayer, alertsSpeaker) = createApplicationMediaPlayer(
-            httpContentFetcherFactory,
-            false,
-            avsCommon::sdkInterfaces::SpeakerInterface::Type::AVS_ALERTS_VOLUME,
-            "AlertsMediaPlayer");
-        if (!m_alertsMediaPlayer || !alertsSpeaker) {
-            TRACE(AVSClient, (_T("Failed to create AlertsMediaPlayer")));
-            return false;
-        }
-
-        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::SpeakerInterface> notificationsSpeaker;
-        std::tie(m_notificationsMediaPlayer, notificationsSpeaker) = createApplicationMediaPlayer(
-            httpContentFetcherFactory,
-            false,
-            avsCommon::sdkInterfaces::SpeakerInterface::Type::AVS_ALERTS_VOLUME,
-            "NotificationsMediaPlayer");
-        if (!m_notificationsMediaPlayer || !notificationsSpeaker) {
-            TRACE(AVSClient, (_T("Failed to create NotificationsMediaPlayer")));
-            return false;
-        }
-
-        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::SpeakerInterface> bluetoothSpeaker;
-        std::tie(m_bluetoothMediaPlayer, bluetoothSpeaker) = createApplicationMediaPlayer(
-            httpContentFetcherFactory,
-            false,
-            avsCommon::sdkInterfaces::SpeakerInterface::Type::AVS_SPEAKER_VOLUME,
-            "BluetoothMediaPlayer");
-        if (!m_bluetoothMediaPlayer || !bluetoothSpeaker) {
-            TRACE(AVSClient, (_T("Failed to create BluetoothMediaPlayer")));
+    using namespace alexaSmartScreenSDK::sampleApp; 
+    using namespace alexaClientSDK::avsCommon::utils::mediaPlayer;
+    using namespace alexaClientSDK::avsCommon::sdkInterfaces;   
+    
+    
+    auto jsonConfig = std::make_shared<std::vector<std::shared_ptr<std::istream>>>();
+    
+    auto configInFile = std::shared_ptr<std::ifstream>(new std::ifstream(alexaClientConfig));
+    if (!configInFile->good()) {
+        TRACE(AVSClient, (_T("Failed to read appConfig file filename")));
             return false;
         }
-
-        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::SpeakerInterface> ringtoneSpeaker;
-        std::tie(m_ringtoneMediaPlayer, ringtoneSpeaker) = createApplicationMediaPlayer(
-            httpContentFetcherFactory,
-            false,
-            avsCommon::sdkInterfaces::SpeakerInterface::Type::AVS_SPEAKER_VOLUME,
-            "RingtoneMediaPlayer");
-        if (!m_ringtoneMediaPlayer || !ringtoneSpeaker) {
-            TRACE(AVSClient, (_T("Failed to create RingtoneMediaPlayer")));
-            return false;
-        }
-
-        std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::SpeakerInterface> systemSoundSpeaker;
-        std::tie(m_systemSoundMediaPlayer, systemSoundSpeaker) = createApplicationMediaPlayer(
-            httpContentFetcherFactory,
-            false,
-            avsCommon::sdkInterfaces::SpeakerInterface::Type::AVS_SPEAKER_VOLUME,
-            "SystemSoundMediaPlayer");
-        if (!m_systemSoundMediaPlayer || !systemSoundSpeaker) {
-            TRACE(AVSClient, (_T("Failed to create SystemSoundMediaPlayer")));
-            return false;
-        }
-
-        auto audioFactory = std::make_shared<alexaClientSDK::applicationUtilities::resources::audio::AudioFactory>();
-        if (!audioFactory) {
-            TRACE(AVSClient, (_T("Failed to create audioFactory")));
+    jsonConfig->push_back(configInFile);
+        auto ssConfig = std::shared_ptr<std::ifstream>(new std::ifstream(smartScreenConfig));
+        if (!ssConfig->good()) {
+        TRACE(AVSClient, (_T("Failed to read smart screen appConfig file filename")));
             return false;
         }
+        jsonConfig->push_back(ssConfig);
 
-        // storage
-        auto authDelegateStorage = authorization::cblAuthDelegate::SQLiteCBLAuthDelegateStorage::create(config);
-
-        auto alertStorage = alexaClientSDK::capabilityAgents::alerts::storage::SQLiteAlertStorage::create(config, audioFactory->alerts());
-        if (!alertStorage) {
-            TRACE(AVSClient, (_T("Failed to create alertStorage")));
-            return false;
-        }
-
-        auto messageStorage = alexaClientSDK::certifiedSender::SQLiteMessageStorage::create(config);
-        if (!messageStorage) {
-            TRACE(AVSClient, (_T("Failed to create messageStorage")));
-            return false;
-        }
-
-        auto notificationsStorage = alexaClientSDK::capabilityAgents::notifications::SQLiteNotificationsStorage::create(config);
-        if (!notificationsStorage) {
-            TRACE(AVSClient, (_T("Failed to create notificationsStorage")));
-            return false;
-        }
-
-        auto deviceSettingsStorage = alexaClientSDK::settings::storage::SQLiteDeviceSettingStorage::create(config);
-        if (!deviceSettingsStorage) {
-            TRACE(AVSClient, (_T("Failed to create deviceSettingsStorage")));
-            return false;
-        }
-
-        std::shared_ptr<storage::sqliteStorage::SQLiteMiscStorage> miscStorage = storage::sqliteStorage::SQLiteMiscStorage::create(config);
-        if (!miscStorage) {
-            TRACE(AVSClient, (_T("Failed to create deviceSettingsStorage")));
-            return false;
-        }
-
-        // Asset Manager
-        auto localeAssetsManager = alexaSmartScreenSDK::sampleApp::LocaleAssetsManager::create(enableKWD);
-        if (!localeAssetsManager) {
-            TRACE(AVSClient, (_T("Failed to create localeAssetsManager")));
-            return false;
-        }
-
-        // SmartScreen connection
-        std::string websocketInterface;
-        int websocketPortNumber;
-        config.getString(WEBSOCKET_INTERFACE_KEY, &websocketInterface, DEFAULT_WEBSOCKET_INTERFACE);
-        config.getInt(WEBSOCKET_PORT_KEY, &websocketPortNumber, DEFAULT_WEBSOCKET_PORT);
-        auto webSocketServer = std::make_shared<alexaSmartScreenSDK::communication::WebSocketServer>(websocketInterface, websocketPortNumber);
-        if (!webSocketServer) {
-            TRACE(AVSClient, (_T("Failed to create webSocketServer")));
+#if defined(KWD_PRYON)
+    if (enableKWD) {
+        auto localeToModelsConfig = pathToInputFolder + "/localeToModels.json";
+        auto ltmConfigInFile = std::shared_ptr<std::ifstream>(new std::ifstream(localeToModelsConfig));
+        if (!ltmConfigInFile->good()) {
+            TRACE(AVSClient, (_T("Failed to read ltm appConfig file filename")));
             return false;
         }
+        jsonConfig->push_back(ltmConfigInFile);
+    }
+#endif
+    auto avsBuilder = alexaClientSDK::avsCommon::avs::initialization::InitializationParametersBuilder::create();
+    avsBuilder->withJsonStreams(jsonConfig);
+    if (!avsBuilder) {
+        TRACE(AVSClient, (_T("createInitializeParamsFailed reason nullBuilder")));
+        return false;
+    }
+    auto params = avsBuilder->build(); 
+    auto avsAppComponent =
+        getComponent(std::move(params), m_shutdownRequiredList);
+    auto avsAppFactory = alexaClientSDK::acsdkManufactory::Manufactory<
+        std::shared_ptr<avsCommon::avs::initialization::AlexaClientSDKInit>,
+        std::shared_ptr<avsCommon::sdkInterfaces::ContextManagerInterface>,
+        std::shared_ptr<avsCommon::sdkInterfaces::LocaleAssetsManagerInterface>,
+        std::shared_ptr<avsCommon::utils::configuration::ConfigurationNode>,
+        std::shared_ptr<avsCommon::utils::DeviceInfo>,
+        std::shared_ptr<registrationManager::CustomerDataManager>,
+        std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>>::create(avsAppComponent);
+    m_sdkInit = avsAppFactory->get<std::shared_ptr<avsCommon::avs::initialization::AlexaClientSDKInit>>();
+    if (!m_sdkInit) {
+        TRACE(AVSClient, (_T("Failed to get SDKInit!")));
+        return false;
+    }
+        auto configEntry = avsAppFactory->get<std::shared_ptr<avsCommon::utils::configuration::ConfigurationNode>>();
+    if (!configEntry) {
+        TRACE(AVSClient, (_T("Failed to acquire the configuration")));
+        return false;
+    }
+    auto& appConfig = *configEntry;
+    auto config = appConfig[SAMPLE_APP_CONFIG_KEY];
 
-        // GUI
-        m_guiClient = alexaSmartScreenSDK::sampleApp::gui::GUIClient::create(webSocketServer, miscStorage);
-        if (!m_guiClient) {
-            TRACE(AVSClient, (_T("Failed to create m_guiClient")));
-            return false;
-        }
+    auto httpFactory = std::make_shared<avsCommon::utils::libcurlUtils::HTTPContentFetcherFactory>();
+     std::shared_ptr<alexaClientSDK::storage::sqliteStorage::SQLiteMiscStorage> miscStorage =
+         alexaClientSDK::storage::sqliteStorage::SQLiteMiscStorage::create(appConfig);
 
-        auto aplCoreConnectionManager = std::make_shared<alexaSmartScreenSDK::sampleApp::AplCoreConnectionManager>(m_guiClient);
-        auto aplCoreGuiRenderer = std::make_shared<alexaSmartScreenSDK::sampleApp::AplCoreGuiRenderer>(aplCoreConnectionManager, httpContentFetcherFactory);
+    bool equalizerEnabled = false;
 
-        m_guiClient->setAplCoreConnectionManager(aplCoreConnectionManager);
-        m_guiClient->setAplCoreGuiRenderer(aplCoreGuiRenderer);
-        if (!m_guiClient->start()) {
-            TRACE(AVSClient, (_T("Failed to start m_guiClient")));
-            return false;
-        }
+    auto speakerInterface = createApplicationMediaPlayer(httpFactory, false, "SpeakMediaPlayer");
+    if (!speakerInterface) {
+        TRACE(AVSClient, (_T("Failed to create application media interfaces for speech!")));
+        return false;
+    }
+    m_speakMediaPlayer = speakerInterface->mediaPlayer;
+    int poolSize;
+    config.getInt(AUDIO_MEDIAPLAYER_POOL_SIZE_KEY, &poolSize, AUDIO_MEDIAPLAYER_POOL_SIZE_DEFAULT);
+    std::vector<std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::SpeakerInterface>> audioDevices;
+    for (int index = 0; index < poolSize; index++) {
 
-        auto userInterfaceManager = std::make_shared<alexaSmartScreenSDK::sampleApp::JsonUIManager>(
-            std::static_pointer_cast<alexaSmartScreenSDK::smartScreenSDKInterfaces::GUIClientInterface>(m_guiClient), deviceInfo);
-        if (!userInterfaceManager) {
-            TRACE(AVSClient, (_T("Failed to create userInterfaceManager")));
+        auto audioMediaInterfaces =
+            createApplicationMediaPlayer(httpFactory, equalizerEnabled, "AudioMediaPlayer");
+        if (!audioMediaInterfaces) {
+            TRACE(AVSClient, (_T("Failed to create application media interfaces for audio!")));
             return false;
         }
-        m_guiClient->setObserver(userInterfaceManager);
-        std::string APLVersion = m_guiClient->getMaxAPLVersion();
+        m_audioMediaPlayerPool.push_back(audioMediaInterfaces->mediaPlayer);
+        audioDevices.push_back(audioMediaInterfaces->speaker);
+    }
 
-        // Context
-        auto contextManager = contextManager::ContextManager::create();
-        if (!contextManager) {
-            TRACE(AVSClient, (_T("Failed to create contextManager")));
-            return false;
-        }
+    avsCommon::utils::Optional<avsCommon::utils::mediaPlayer::Fingerprint> fingerprint =
+        (*(m_audioMediaPlayerPool.begin()))->getFingerprint();
+    auto appAudioPlayerFactory = std::unique_ptr<mediaPlayer::PooledMediaPlayerFactory>();
+    if (fingerprint.hasValue()) {
+        appAudioPlayerFactory =
+            mediaPlayer::PooledMediaPlayerFactory::create(m_audioMediaPlayerPool, fingerprint.value());
+    } else {
+        appAudioPlayerFactory = mediaPlayer::PooledMediaPlayerFactory::create(m_audioMediaPlayerPool);
+    }
+    if (!appAudioPlayerFactory) {
+        TRACE(AVSClient, (_T("Failed to create media player factory for content!")));
+        return false;
+    }
+    auto notificationInterface =
+        createApplicationMediaPlayer(httpFactory, false, "NotificationsMediaPlayer");
+    if (!notificationInterface) {
+        TRACE(AVSClient, (_T("Failed to create application media interfaces for notifications!")));
+        return false;
+    }
+    m_notificationsMediaPlayer = notificationInterface->mediaPlayer;
+    auto btInterface =
+        createApplicationMediaPlayer(httpFactory, false, "BluetoothMediaPlayer");
+    if (!btInterface) {
+        TRACE(AVSClient, (_T("Failed to create application media interfaces for bluetooth!")));
+        return false;
+    }
+    m_bluetoothMediaPlayer = btInterface->mediaPlayer;
+    auto rtInterface =
+        createApplicationMediaPlayer(httpFactory, false, "RingtoneMediaPlayer");
+    if (!rtInterface) {
+        TRACE(AVSClient, (_T("Failed to create application media interfaces for ringtones!")));
+        return false;
+    }
+    m_ringtoneMediaPlayer = rtInterface->mediaPlayer;
 
-        // AVS Authorization
-        std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface> authDelegate = authorization::cblAuthDelegate::CBLAuthDelegate::create(
-            config, customerDataManager, std::move(authDelegateStorage), userInterfaceManager, nullptr, deviceInfo);
-        if (!authDelegate) {
-            TRACE(AVSClient, (_T("Failed to create authDelegate")));
-            return false;
-        }
-        authDelegate->addAuthObserver(userInterfaceManager);
-
-        // AVS Connection
-        std::shared_ptr<avsCommon::utils::libcurlUtils::HttpPut> httpPut = avsCommon::utils::libcurlUtils::HttpPut::create();
-        m_capabilitiesDelegate = alexaClientSDK::capabilitiesDelegate::CapabilitiesDelegate::create(
-            authDelegate, miscStorage, httpPut, customerDataManager, config, deviceInfo);
-        if (!m_capabilitiesDelegate) {
-            TRACE(AVSClient, (_T("Failed to create m_capabilitiesDelegate")));
-            return false;
-        }
-        m_capabilitiesDelegate->addCapabilitiesObserver(userInterfaceManager);
 
-        auto postConnectSynchronizerFactory = acl::PostConnectSynchronizerFactory::create(contextManager);
-        if (!postConnectSynchronizerFactory) {
-            TRACE(AVSClient, (_T("Failed to create postConnectSynchronizerFactory")));
-            return false;
-        }
+    auto alertInterface = createApplicationMediaPlayer(httpFactory, false, "AlertsMediaPlayer");
+    if (!alertInterface) {
+        TRACE(AVSClient, (_T("Failed to create application media interfaces for alerts!")));
+        return false;
+    }
+    m_alertsMediaPlayer = alertInterface->mediaPlayer;
+    auto appSystemAudioInterface =
+        createApplicationMediaPlayer(httpFactory, false, "SystemSoundMediaPlayer");
+    if (!appSystemAudioInterface) {
+        TRACE(AVSClient, (_T("Failed to create application media interfaces for system sound player!")));
+        return false;
+    }
+    m_systemSoundMediaPlayer = appSystemAudioInterface->mediaPlayer;
+
+
+    auto appAudioFactory = std::make_shared<alexaClientSDK::applicationUtilities::resources::audio::AudioFactory>();
+    auto alertStorage =
+        alexaClientSDK::acsdkAlerts::storage::SQLiteAlertStorage::create(appConfig, appAudioFactory->alerts());
+    auto appMsgStorage = alexaClientSDK::certifiedSender::SQLiteMessageStorage::create(appConfig);
+    auto appNotifStorage = alexaClientSDK::acsdkNotifications::SQLiteNotificationsStorage::create(appConfig);
+    
+    auto appDevSettingStorage = alexaClientSDK::settings::storage::SQLiteDeviceSettingStorage::create(appConfig);
+    
+    auto appLocaleManager = avsAppFactory->get<std::shared_ptr<LocaleAssetsManagerInterface>>();
+    if (!appLocaleManager) {
+        TRACE(AVSClient, (_T("Failed to create Locale Assets Manager!")));
+        return false;
+    }
+    
+    std::string APLVersion;
+    std::string websocketInterface;
+    appConfig.getString(WEBSOCKET_INTERFACE_KEY, &websocketInterface, DEFAULT_WEBSOCKET_INTERFACE);
+    int websocketPortNumber;
+    appConfig.getInt(WEBSOCKET_PORT_KEY, &websocketPortNumber, DEFAULT_WEBSOCKET_PORT);
+
+#ifdef UWP_BUILD
+    auto webSocketServer = std::make_shared<NullSocketServer>();
+#else
+    auto webSocketServer = std::make_shared<alexaSmartScreenSDK::communication::WebSocketServer>(websocketInterface, websocketPortNumber);
+#ifdef ENABLE_WEBSOCKET_SSL
+    std::string sslCaFile;
+    appConfig.getString(WEBSOCKET_CERTIFICATE_AUTHORITY, &sslCaFile);
+    std::string sslCertificateFile;
+    appConfig.getString(WEBSOCKET_CERTIFICATE, &sslCertificateFile);
 
-        auto internetConnectionMonitor = avsCommon::utils::network::InternetConnectionMonitor::create(httpContentFetcherFactory);
-        if (!internetConnectionMonitor) {
-            TRACE(AVSClient, (_T("Failed to create internetConnectionMonitor")));
-            return false;
-        }
+    std::string sslPrivateKeyFile;
+    appConfig.getString(WEBSOCKET_PRIVATE_KEY, &sslPrivateKeyFile);
 
-        auto transportFactory = std::make_shared<acl::HTTP2TransportFactory>(
-            std::make_shared<avsCommon::utils::libcurlUtils::LibcurlHTTP2ConnectionFactory>(),
-            postConnectSynchronizerFactory);
-        if (!transportFactory) {
-            TRACE(AVSClient, (_T("Failed to create transportFactory")));
-            return false;
-        }
+    webSocketServer->setCertificateFile(sslCaFile, sslCertificateFile, sslPrivateKeyFile);
+#endif  // ENABLE_WEBSOCKET_SSL
 
-        // MAIN CLIENT
-        std::shared_ptr<alexaSmartScreenSDK::smartScreenClient::SmartScreenClient> client = alexaSmartScreenSDK::smartScreenClient::SmartScreenClient::create(
-            deviceInfo,
-            customerDataManager,
-            m_externalMusicProviderMediaPlayersMap,
-            m_externalMusicProviderSpeakersMap,
-            m_adapterToCreateFuncMap,
-            m_speakMediaPlayer,
-            m_audioMediaPlayer,
-            m_alertsMediaPlayer,
-            m_notificationsMediaPlayer,
-            m_bluetoothMediaPlayer,
-            m_ringtoneMediaPlayer,
-            m_systemSoundMediaPlayer,
-            speakSpeaker,
-            audioSpeaker,
-            alertsSpeaker,
-            notificationsSpeaker,
-            bluetoothSpeaker,
-            ringtoneSpeaker,
-            systemSoundSpeaker,
-            std::vector<std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::SpeakerInterface>>(),
-            nullptr,
-            audioFactory,
-            authDelegate,
-            std::move(alertStorage),
-            std::move(messageStorage),
-            std::move(notificationsStorage),
-            std::move(deviceSettingsStorage),
-            nullptr,
-            std::move(miscStorage),
-            { userInterfaceManager },
-            { userInterfaceManager },
-            std::move(internetConnectionMonitor),
-            m_capabilitiesDelegate,
-            contextManager,
-            transportFactory,
-            localeAssetsManager,
-            nullptr,
-            firmwareVersion,
-            true,
-            nullptr,
-            nullptr,
-            m_guiManager,
-            APLVersion);
-
-        if (!client) {
-            TRACE(AVSClient, (_T("Failed to create default SDK client")));
-            return false;
-        }
+#endif  // UWP_BUILD
 
-        client->addSpeakerManagerObserver(userInterfaceManager);
-        client->addNotificationsObserver(userInterfaceManager);
+    auto appCustDataManager = avsAppFactory->get<std::shared_ptr<registrationManager::CustomerDataManager>>();
+    if (!appCustDataManager) {
+        TRACE(AVSClient, (_T("Failed to get CustomerDataManager!")));
+        return false;
+    }
+     m_guiClient = gui::GUIClient::create(webSocketServer, miscStorage, appCustDataManager);
+    if (!m_guiClient) {
+        TRACE(AVSClient, (_T("Creation of GUIClient failed!")));
+        return false;
+    }
+    std::string cachePeriodInSeconds;
+    std::string maxCacheSize;
+
+    appConfig.getString(
+        CONTENT_CACHE_REUSE_PERIOD_IN_SECONDS_KEY,
+        &cachePeriodInSeconds,
+        DEFAULT_CONTENT_CACHE_REUSE_PERIOD_IN_SECONDS);
+    appConfig.getString(CONTENT_CACHE_MAX_SIZE_KEY, &maxCacheSize, DEFAULT_CONTENT_CACHE_MAX_SIZE);
+    auto appContDwlManager = std::make_shared<CachingDownloadManager>(
+        httpFactory,
+        std::stol(cachePeriodInSeconds),
+        std::stol(maxCacheSize),
+        miscStorage,
+        appCustDataManager);
+    int maxConcDwls;
+    appConfig.getInt(
+        MAX_NUMBER_OF_CONCURRENT_DOWNLOAD_CONFIGURATION_KEY,
+        &maxConcDwls,
+        DEFAULT_MAX_NUMBER_OF_CONCURRENT_DOWNLOAD);
+
+    if (1 > maxConcDwls) {
+        maxConcDwls = DEFAULT_MAX_NUMBER_OF_CONCURRENT_DOWNLOAD;
+        TRACE(AVSClient, (_T("Invalid values for maxConcDwls")));
+    }
+    auto aplParams = AplClientBridgeParameter{maxConcDwls};
+    auto aplClientBridge = AplClientBridge::create(appContDwlManager, m_guiClient, aplParams);
+    m_guiClient->setAplClientBridge(aplClientBridge);
 
-        // Shared Data stream
-        size_t bufferSize = alexaClientSDK::avsCommon::avs::AudioInputStream::calculateBufferSize(
-            BUFFER_SIZE_IN_SAMPLES, WORD_SIZE, MAX_READERS);
-        auto buffer = std::make_shared<alexaClientSDK::avsCommon::avs::AudioInputStream::Buffer>(bufferSize);
-        std::shared_ptr<alexaClientSDK::avsCommon::avs::AudioInputStream> sharedDataStream = alexaClientSDK::avsCommon::avs::AudioInputStream::create(buffer, WORD_SIZE, MAX_READERS);
-        if (!sharedDataStream) {
-            TRACE(AVSClient, (_T("Failed to create sharedDataStream")));
-            return false;
-        }
+    
+    auto captionPresenter = std::make_shared<alexaSmartScreenSDK::sampleApp::SmartScreenCaptionPresenter>(m_guiClient);
 
-        // Audio providers
-        alexaClientSDK::avsCommon::utils::AudioFormat compatibleAudioFormat;
-        compatibleAudioFormat.sampleRateHz = SAMPLE_RATE_HZ;
-        compatibleAudioFormat.sampleSizeInBits = WORD_SIZE * CHAR_BIT;
-        compatibleAudioFormat.numChannels = NUM_CHANNELS;
-        compatibleAudioFormat.endianness = alexaClientSDK::avsCommon::utils::AudioFormat::Endianness::LITTLE;
-        compatibleAudioFormat.encoding = alexaClientSDK::avsCommon::utils::AudioFormat::Encoding::LPCM;
-
-        alexaClientSDK::capabilityAgents::aip::AudioProvider tapToTalkAudioProvider(
-            sharedDataStream,
-            compatibleAudioFormat,
-            alexaClientSDK::capabilityAgents::aip::ASRProfile::NEAR_FIELD,
-            true, // alwaysReadable
-            true, // canOverride
-            true); // canBeOverridden
-
-        alexaClientSDK::capabilityAgents::aip::AudioProvider holdToTalkAudioProvider(
-            sharedDataStream,
-            compatibleAudioFormat,
-            alexaClientSDK::capabilityAgents::aip::ASRProfile::CLOSE_TALK,
-            false, // alwaysReadable
-            true, // canOverride
-            false); // canBeOverridden
-
-        alexaClientSDK::capabilityAgents::aip::AudioProvider wakeWordAudioProvider(capabilityAgents::aip::AudioProvider::null());
-#if defined(KWD_PRYON)
-        if (enableKWD) {
-            wakeWordAudioProvider = alexaClientSDK::capabilityAgents::aip::AudioProvider(sharedDataStream,
-                compatibleAudioFormat,
-                alexaClientSDK::capabilityAgents::aip::ASRProfile::NEAR_FIELD,
-                true, // alwaysReadable
-                false, // canOverride
-                true); // canBeOverridden
-        }
-#endif
+    auto appDevInfo = avsAppFactory->get<std::shared_ptr<avsCommon::utils::DeviceInfo>>();
+    if (!appDevInfo) {
+        TRACE(AVSClient, (_T("Creation of DeviceInfo failed!")));
+        return false;
+    }
 
+    auto appUI = std::make_shared<alexaSmartScreenSDK::sampleApp::JsonUIManager>(
+        std::static_pointer_cast<alexaSmartScreenSDK::smartScreenSDKInterfaces::GUIClientInterface>(m_guiClient),
+        appDevInfo);
+    m_guiClient->setObserver(appUI);
+    APLVersion = m_guiClient->getMaxAPLVersion();
+    
+    alexaClientSDK::avsCommon::utils::uuidGeneration::setSalt(
+        appDevInfo->getClientId() + appDevInfo->getDeviceSerialNumber());
+    
+    auto appAuthDelStorage = authorization::cblAuthDelegate::SQLiteCBLAuthDelegateStorage::create(appConfig);
+    std::shared_ptr<avsCommon::sdkInterfaces::AuthDelegateInterface> delAuth =
+        authorization::cblAuthDelegate::CBLAuthDelegate::create(
+            appConfig, appCustDataManager, std::move(appAuthDelStorage), appUI, nullptr, appDevInfo);
+
+    if (!delAuth) {
+        TRACE(AVSClient, (_T("Creation of AuthDelegate failed!")));
+        return false;
+    }
+   
+    auto appCDStorage =
+        alexaClientSDK::capabilitiesDelegate::storage::SQLiteCapabilitiesDelegateStorage::create(appConfig);
+    m_capabilitiesDelegate = alexaClientSDK::capabilitiesDelegate::CapabilitiesDelegate::create(
+        delAuth, std::move(appCDStorage), appCustDataManager);
+    if (!m_capabilitiesDelegate) {
+         TRACE(AVSClient, (_T("Creation of CapabilitiesDelegate failed!")));
+        return false;
+    }
+    m_shutdownRequiredList.push_back(m_capabilitiesDelegate);
+    delAuth->addAuthObserver(appUI);
+    m_capabilitiesDelegate->addCapabilitiesObserver(appUI);
+
+    int firmwareVersion = static_cast<int>(avsCommon::sdkInterfaces::softwareInfo::INVALID_FIRMWARE_VERSION);
+    config.getInt(FIRMWARE_VERSION_KEY, &firmwareVersion, firmwareVersion);
+    
+    auto appICMonitor =
+        avsCommon::utils::network::InternetConnectionMonitor::create(httpFactory);
+    if (!appICMonitor) {
+        TRACE(AVSClient, (_T("Failed to create InternetConnectionMonitor")));
+        return false;
+    }
+    
+    auto appCtxtManager = avsAppFactory->get<std::shared_ptr<ContextManagerInterface>>();
+    if (!appCtxtManager) {
+        TRACE(AVSClient, (_T("Creation of ContextManager failed.")));
+        return false;
+    }
+    auto appGWMStorage = avsGatewayManager::storage::AVSGatewayManagerStorage::create(miscStorage);
+    if (!appGWMStorage) {
+        TRACE(AVSClient, (_T("Creation of AVSGatewayManagerStorage failed")));
+        return false;
+    }
+    auto appGWManager =
+        avsGatewayManager::AVSGatewayManager::create(std::move(appGWMStorage), appCustDataManager, appConfig);
+    if (!appGWManager) {
+        TRACE(AVSClient, (_T("Creation of AVSGatewayManager failed")));
+        return false;
+    }
+    auto appSyncFactory = synchronizeStateSender::SynchronizeStateSenderFactory::create(appCtxtManager);
+    if (!appSyncFactory) {
+        TRACE(AVSClient, (_T("Creation of SynchronizeStateSenderFactory failed")));
+        return false;
+    }
+    
+
+    std::vector<std::shared_ptr<avsCommon::sdkInterfaces::PostConnectOperationProviderInterface>> providers;
+    providers.push_back(appSyncFactory);
+    providers.push_back(appGWManager);
+    providers.push_back(m_capabilitiesDelegate);
+    
+    auto postConnectSequencerFactory = acl::PostConnectSequencerFactory::create(providers);
+   
+    auto appHttpTransport = std::make_shared<acl::HTTP2TransportFactory>(
+        std::make_shared<avsCommon::utils::libcurlUtils::LibcurlHTTP2ConnectionFactory>(),
+        postConnectSequencerFactory,
+        nullptr,
+        nullptr);
+    
+    size_t bufferSize = alexaClientSDK::avsCommon::avs::AudioInputStream::calculateBufferSize(
+        BUFFER_SIZE_IN_SAMPLES, WORD_SIZE, MAX_READERS);
+    auto tmpBuffer = std::make_shared<alexaClientSDK::avsCommon::avs::AudioInputStream::Buffer>(bufferSize);
+    std::shared_ptr<alexaClientSDK::avsCommon::avs::AudioInputStream> sharedDataStream =
+        alexaClientSDK::avsCommon::avs::AudioInputStream::create(tmpBuffer, WORD_SIZE, MAX_READERS);
+    if (!sharedDataStream) {
+        TRACE(AVSClient, (_T("Failed to create shared data stream!")));
+        return false;
+    }
+    
+
+    alexaClientSDK::avsCommon::utils::AudioFormat appAudioFromat;
+    appAudioFromat.sampleRateHz = SAMPLE_RATE_HZ;
+    appAudioFromat.sampleSizeInBits = WORD_SIZE * CHAR_BIT;
+    appAudioFromat.numChannels = NUM_CHANNELS;
+    appAudioFromat.endianness = alexaClientSDK::avsCommon::utils::AudioFormat::Endianness::LITTLE;
+    appAudioFromat.encoding = alexaClientSDK::avsCommon::utils::AudioFormat::Encoding::LPCM;
+    appAudioFromat.dataSigned = false;
+    
+    
+    alexaClientSDK::capabilityAgents::aip::AudioProvider appTapAudioProv(
+        sharedDataStream,
+        appAudioFromat,
+        alexaClientSDK::capabilityAgents::aip::ASRProfile::NEAR_FIELD,
+        true,
+        true,
+        true);
+    
+    alexaClientSDK::capabilityAgents::aip::AudioProvider appHoldAudioProv(
+        sharedDataStream,
+        appAudioFromat,
+        alexaClientSDK::capabilityAgents::aip::ASRProfile::CLOSE_TALK,
+        false,
+        true,
+        false);
+        
+    auto appMetrics = avsAppFactory->get<std::shared_ptr<avsCommon::utils::metrics::MetricRecorderInterface>>();
+    
+    
         // Audio input
         std::shared_ptr<applicationUtilities::resources::audio::MicrophoneInterface> aspInput = nullptr;
         std::shared_ptr<InteractionHandler<alexaSmartScreenSDK::sampleApp::gui::GUIManager>> aspInputInteractionHandler = nullptr;
@@ -508,8 +573,7 @@ namespace Plugin {
                 TRACE(AVSClient, (_T("Failed to create aspInputInteractionHandler")));
                 return false;
             }
-
-            m_thunderVoiceHandler = ThunderVoiceHandler<alexaSmartScreenSDK::sampleApp::gui::GUIManager>::create(sharedDataStream, _service, audiosource, aspInputInteractionHandler, compatibleAudioFormat);
+            m_thunderVoiceHandler = ThunderVoiceHandler<alexaSmartScreenSDK::sampleApp::gui::GUIManager>::create(sharedDataStream, _service, audiosource, aspInputInteractionHandler, appAudioFromat);
             aspInput = m_thunderVoiceHandler;
             aspInput->startStreamingMicrophoneData();
         }
@@ -517,34 +581,47 @@ namespace Plugin {
             TRACE(AVSClient, (_T("Failed to create aspInput")));
             return false;
         }
-
-        // Key Word Detection
+       
+      alexaClientSDK::capabilityAgents::aip::AudioProvider
+      appWakeAudioProv(capabilityAgents::aip::AudioProvider::null());
+      
+// Creating wake word audio provider, if necessary
 #if defined(KWD_PRYON)
-        if (enableKWD) {
-            auto keywordObserver = std::make_shared<alexaSmartScreenSDK::sampleApp::KeywordObserver>(client, wakeWordAudioProvider);
-            m_keywordDetector = PryonKeywordDetector::create(
-                sharedDataStream,
-                compatibleAudioFormat,
-                { keywordObserver },
-                std::unordered_set<
-                    std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::KeyWordDetectorStateObserverInterface>>(),
-                pathToInputFolder);
-            if (!m_keywordDetector) {
-                TRACE(AVSClient, (_T("Failed to create m_keywordDetector")));
-                return false;
-            }
-        }
-#endif
-        // GUI manager / Interaction manager
+    if (enableKWD) {
+    appWakeAudioProv = alexaClientSDK::capabilityAgents::aip::AudioProvider(
+        sharedDataStream,
+        appAudioFromat,
+        alexaClientSDK::capabilityAgents::aip::ASRProfile::NEAR_FIELD,
+        true,
+        false,
+        true);
+    
+    
         m_guiManager = alexaSmartScreenSDK::sampleApp::gui::GUIManager::create(
-            m_guiClient,
-            holdToTalkAudioProvider,
-            tapToTalkAudioProvider,
-            aspInput,
-            wakeWordAudioProvider);
-
-        // Interaction Manager
-        if (audiosource != PORTAUDIO_CALLSIGN) {
+        m_guiClient,
+#ifdef ENABLE_PCC
+        phoneCaller,
+#endif
+        appHoldAudioProv,
+        appTapAudioProv,
+        aspInput,
+        appWakeAudioProv);
+}
+#else
+   
+    m_guiManager = alexaSmartScreenSDK::sampleApp::gui::GUIManager::create(
+        m_guiClient,
+#ifdef ENABLE_PCC
+        phoneCaller,
+#endif
+        appHoldAudioProv,
+        appTapAudioProv,
+        aspInput,
+        alexaClientSDK::capabilityAgents::aip::AudioProvider::null());
+        
+
+#endif
+    if (audiosource != PORTAUDIO_CALLSIGN) {
             if (aspInputInteractionHandler) {
                 // register interactions that ThunderVoiceHandler may initiate
                 if (!aspInputInteractionHandler->Initialize(m_guiManager)) {
@@ -553,35 +630,137 @@ namespace Plugin {
                 }
             }
         }
+        
+    
+    std::shared_ptr<alexaSmartScreenSDK::smartScreenClient::SmartScreenClient> client = alexaSmartScreenSDK::smartScreenClient::SmartScreenClient::create(
+        appDevInfo,
+        appCustDataManager,
+        m_externalMusicProviderMediaPlayersMap,
+        m_externalMusicProviderSpeakersMap,
+        m_adapterToCreateFuncMap,
+        m_speakMediaPlayer,
+        std::move(appAudioPlayerFactory),
+        m_alertsMediaPlayer,
+        m_notificationsMediaPlayer,
+        m_bluetoothMediaPlayer,
+        m_ringtoneMediaPlayer,
+        m_systemSoundMediaPlayer,
+        speakerInterface->speaker,
+        audioDevices,
+        alertInterface->speaker,
+        notificationInterface->speaker,
+        btInterface->speaker,
+        rtInterface->speaker,
+        appSystemAudioInterface->speaker,
+        {},
+        nullptr, //equalizerRuntimeSetup,
+        appAudioFactory,
+        delAuth,
+        std::move(alertStorage),
+        std::move(appMsgStorage),
+        std::move(appNotifStorage),
+        std::move(appDevSettingStorage),
+        nullptr, //std::move(bluetoothStorage),
+        miscStorage,
+        {appUI},
+        {appUI},
+        std::move(appICMonitor),
+        m_capabilitiesDelegate,
+        appCtxtManager,
+        appHttpTransport,
+        appGWManager,
+        appLocaleManager,
+        {}, //enabledConnectionRules,
+        /* systemTimezone*/ nullptr,
+        firmwareVersion,
+        true,
+        nullptr,
+        nullptr, //std::move(bluetoothDeviceManager),
+        appMetrics,
+        nullptr,
+        nullptr, //diagnostics,
+        std::make_shared<ExternalCapabilitiesBuilder>(appDevInfo),
+        std::make_shared<alexaClientSDK::capabilityAgents::speakerManager::DefaultChannelVolumeFactory>(),
+        true,
+        std::make_shared<alexaClientSDK::acl::MessageRouterFactory>(),
+        nullptr,
+        capabilityAgents::aip::AudioProvider::null(),
+        m_guiManager,
+        APLVersion);
+    if (!client) {
+        TRACE(AVSClient, (_T("Failed to create default SDK client!")));
+        return false;
+    }
+    
+#if defined(KWD_PRYON)
+    if (enableKWD) {    
+    auto kwObserver = std::make_shared<alexaSmartScreenSDK::sampleApp::KeywordObserver>(client, appWakeAudioProv);
+    m_keywordDetector = PryonKeywordDetector::create(
+        sharedDataStream,
+        appAudioFromat,
+        {kwObserver},
+        std::unordered_set<
+            std::shared_ptr<alexaClientSDK::avsCommon::sdkInterfaces::KeyWordDetectorStateObserverInterface>>(),
+        pathToInputFolder);
+    if (!m_keywordDetector) {
+        TRACE(AVSClient, (_T("Failed to create keyword detector!")));
+    }
+        
+    }
+#endif
 
-        // skillmapper
-        vta.handleStateChangeNotification(skillmapper::VoiceSDKState::VTA_INIT, true);
-        client->addSpeakerManagerObserver(userInterfaceManager);
-        client->addNotificationsObserver(userInterfaceManager);
-        client->addTemplateRuntimeObserver(m_guiManager);
-        client->addAlexaPresentationObserver(m_guiManager);
-        client->addAlexaDialogStateObserver(m_guiManager);
-        client->addAudioPlayerObserver(m_guiManager);
-
-        client->getRegistrationManager()->addObserver(m_guiClient);
-
-        m_guiManager->setClient(client);
-        m_guiClient->setGUIManager(m_guiManager);
-        authDelegate->addAuthObserver(m_guiClient);
-
-        m_capabilitiesDelegate->addCapabilitiesObserver(m_guiClient);
-        m_capabilitiesDelegate->addCapabilitiesObserver(client);
+    client->addSpeakerManagerObserver(appUI);
+    client->addNotificationsObserver(appUI);
+    client->addTemplateRuntimeObserver(m_guiManager);
+    client->addAlexaPresentationObserver(m_guiManager);
+    client->addAlexaDialogStateObserver(m_guiManager);
+    client->addAudioPlayerObserver(m_guiManager);
+    client->addAudioPlayerObserver(aplClientBridge);
+    client->addCallStateObserver(m_guiManager);
+    client->addFocusManagersObserver(m_guiManager);
+    client->addAudioInputProcessorObserver(m_guiManager);
+    m_guiManager->setClient(client);
+    m_guiClient->setGUIManager(m_guiManager);
+    
+    m_shutdownManager = client->getShutdownManager();
+    if (!m_shutdownManager) {
+        TRACE(AVSClient, (_T("Failed to get ShutdownManager!")));
+        return false;
+    }
 
-        // START
-        std::string endpoint;
-        config.getString(ENDPOINT_KEY, &endpoint);
-        client->connect(m_capabilitiesDelegate, endpoint);
+    // Thunder Input Manager
+    m_thunderInputManager = ThunderInputManager::create(m_guiManager);
+    if (!m_thunderInputManager) {
+        TRACE(AVSClient, (_T("Failed to create m_thunderInputManager")));
+      return false;
+    }
 
-        return true;
+    delAuth->addAuthObserver(m_guiClient);
+    client->getRegistrationManager()->addObserver(m_guiClient);
+    m_capabilitiesDelegate->addCapabilitiesObserver(m_guiClient);
+    m_guiManager->setDoNotDisturbSettingObserver(m_guiClient);
+    m_guiManager->configureSettingsNotifications();
+    if (!m_guiClient->start()) {
+        return false;
+    }
+    
+    
+    //delAuth->addAuthObserver(m_thunderInputManager);
+    client->addAlexaDialogStateObserver(m_thunderInputManager);
+    client->addAudioPlayerObserver(m_thunderInputManager);
+
+    // skillmapper
+    // since smartscreen sdk is just initialized pass audioPlayer state as false(not playing).
+    vta.handleSDKStateChangeNotification(skillmapper::VoiceSDKState::VTA_INIT, true, false);
+
+    client->connect();
+    return true;
     }
 
+      
     bool SmartScreen::InitSDKLogs(const string& logLevel)
     {
+//#if 1
         bool status = true;
         std::shared_ptr<avsCommon::utils::logger::Logger> thunderLogger = avsCommon::utils::logger::getThunderLogger();
         avsCommon::utils::logger::Level logLevelValue = avsCommon::utils::logger::Level::UNKNOWN;
@@ -603,12 +782,14 @@ namespace Plugin {
             thunderLogger->setLevel(logLevelValue);
             avsCommon::utils::logger::LoggerSinkManager::instance().initialize(thunderLogger);
         }
-
+#if 0
         if (status == true) {
             apl::LoggerFactory::instance().initialize(std::make_shared<alexaSmartScreenSDK::sampleApp::AplCoreEngineSDKLogBridge>(alexaSmartScreenSDK::sampleApp::AplCoreEngineSDKLogBridge()));
         }
 
         return status;
+    #endif
+    return true;
     }
 
     bool SmartScreen::JsonConfigToStream(std::vector<std::shared_ptr<std::istream>>& streams, const std::string& configFile)
@@ -625,6 +806,7 @@ namespace Plugin {
         }
 
         streams.push_back(configStream);
+        return true;
     }
 
     bool SmartScreen::Deinitialize()
@@ -648,3 +830,5 @@ namespace Plugin {
     }
 }
 }
+
+
diff --git a/WPEPluginAVS/Impl/SmartScreen/SmartScreen.h b/WPEPluginAVS/Impl/SmartScreen/SmartScreen.h
index 4a53485..87a50f0 100644
--- a/WPEPluginAVS/Impl/SmartScreen/SmartScreen.h
+++ b/WPEPluginAVS/Impl/SmartScreen/SmartScreen.h
@@ -18,7 +18,7 @@
  */
 
 #pragma once
-
+#include "ThunderInputManager.h"
 #include "ThunderVoiceHandler.h"
 
 #include <WPEFramework/interfaces/IAVSClient.h>
@@ -42,6 +42,7 @@ namespace Plugin {
     public:
         SmartScreen()
             : _service(nullptr)
+            , m_thunderInputManager(nullptr)
             , m_thunderVoiceHandler(nullptr)
         {
            Run();
@@ -116,12 +117,14 @@ namespace Plugin {
         END_INTERFACE_MAP
 
     private:
-        bool Init(const std::string& audiosource, const bool enableKWD, const std::string& pathToInputFolder);
+        bool Init(const std::string& audiosource, const bool enableKWD, const std::string& pathToInputFolder, const
+        std::string alexaClientConfig, const std::string smartScreenConfig);
         bool InitSDKLogs(const string& logLevel);
         bool JsonConfigToStream(std::vector<std::shared_ptr<std::istream>>& streams, const std::string& configFile);
 
     private:
         WPEFramework::PluginHost::IShell* _service;
+        std::shared_ptr<ThunderInputManager> m_thunderInputManager;
         std::shared_ptr<ThunderVoiceHandler<alexaSmartScreenSDK::sampleApp::gui::GUIManager>> m_thunderVoiceHandler;
 #if defined(KWD_PRYON)
         std::unique_ptr<alexaClientSDK::kwd::AbstractKeywordDetector> m_keywordDetector;
-- 
2.24.0

